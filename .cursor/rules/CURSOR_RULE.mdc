---
alwaysApply: true
---

# ğŸ“Š Reguli de Programare - AplicaÈ›ie Pulsoximetrie


## ğŸ¯ Cele 11 Principii Fundamentale

1. **Claritate** - Nume descriptive, funcÈ›ii < 50 linii, zero magic numbers
2. **RobusteÈ›e** - Validare comprehensivÄƒ CSV, error handling, graceful degradation
3. **PerformanÈ›Äƒ** - Procesare eficientÄƒ date masive, caching grafice, optimizare memorie
4. **Modularitate** - Separation of Concerns: parser, generator, processor, callbacks
5. **Securitate** - Date anonimizate (fÄƒrÄƒ date personale), link-uri token-based, validare uploads
6. **Testabilitate** - Unit tests pentru parsing, integration tests pentru workflow
7. **Mentenabilitate** - Cod organizat modular, docstrings Python, configurare externÄƒ
8. **Observabilitate** - Logging structurat (logger_setup.py), metrics procesare
9. **Portabilitate** - Responsive design (Dash), mobile-friendly, multi-browser
10. **RezilienÈ›Äƒ** - Recuperare din erori CSV corupte, retry logic, fallback values
11. **EticÄƒ** - Date anonime by design, accessibility, code review, zero duplication

## ğŸ‘¥ Echipa de Dezvoltare VirtualÄƒ (21 Membri)

Pentru fiecare task, formezi mental o echipÄƒ diversÄƒ din:
- 3 ArhitecÈ›i de Programare
- 3 Programatori Seniori Python/Data Science
- 3 UI/UX Seniori (Medical UX)
- 3 Manageri de Proiect
- 3 Testeri (inclusiv date medicale)
- 3 Programatori Creativi
- 3 Programatori Critici

## ğŸ”„ Procesul de Colaborare

### Faza 3: Propunerea de SoluÈ›ii (Creativi + Seniori)
1. **Minim 5 soluÈ›ii diferite** pentru fiecare problemÄƒ
2. Evaluarea Pro/Contra pentru fiecare
3. Votul echipei pentru cea mai bunÄƒ soluÈ›ie

## ğŸ—ï¸ Stack Tehnologic

**Current (Local Application):**
- **Framework**: Dash (Python-based web framework)
- **Data Processing**: pandas, numpy
- **Visualization**: Plotly (interactive graphs)
- **Image Export**: Kaleido
- **File Watching**: watchdog

**Future (Cloud Platform):**
- **Frontend**: Dash + React components
- **Backend**: FastAPI + Python
- **Database**: PostgreSQL (Neon/Supabase)
- **Storage**: Cloudflare R2 / MinIO
- **PDF Processing**: pdfplumber / PyMuPDF
- **Deployment**: Railway / Render + Docker

## ğŸ”§ Quality Gates

### Pre-Commit Checklist:
- [ ] Python type hints adÄƒugate (mypy compatible)
- [ ] No linting errors (pylint/flake8)
- [ ] Tests pass pentru parsing È™i procesare
- [ ] Manual testing (Chrome, Firefox, Edge)
- [ ] Mobile responsive (Dash layout)
- [ ] Logging added (min 5 per feature Ã®n logger_setup.py)
- [ ] Error handling pentru CSV corrupt/invalid
- [ ] Validare date medicale (SaO2: 0-100, Puls: 30-200)

## ğŸ“Š Exemple de Cod

### Format CSV Valid (REAL - Din Aparat Checkme O2)
```csv
Timp,Nivel de oxigen,Puls cardiac,MiÅŸcare
20:35:10 15/10/2025,92,78,0
20:35:14 15/10/2025,92,78,0
20:35:18 15/10/2025,93,78,0
20:35:22 15/10/2025,94,77,0
20:35:26 15/10/2025,92,76,1
```

**Coloane (Ã®n RomÃ¢nÄƒ!):**
- **Timp** â†’ Format: `HH:MM:SS DD/MM/YYYY` (ex: `20:35:10 15/10/2025`)
- **Nivel de oxigen** â†’ SpO2 (%) - 0-100
- **Puls cardiac** â†’ Puls (bpm) - 30-200
- **MiÅŸcare** â†’ Indicator miÈ™care (0-25+) - pentru detectare zgomot/artefacte

**Filename Format:**
```
Checkme O2 [APARAT]_[YYYYMMDDHHMMSS].csv
```
Exemple:
- `Checkme O2 0331_20251015203510.csv` â†’ Aparat 0331, Start: 15 Oct 2025 20:35:10
- `Checkme O2 3539_20250502233000.csv` â†’ Aparat 3539, Start: 2 Mai 2025 23:30:00

**ATENÈšIE:** CSV-ul NU conÈ›ine:
- âŒ Nume/Prenume pacient
- âŒ CNP/Date naÈ™tere
- âŒ Telefon/Email
- âŒ AdresÄƒ pacient
- âŒ NumÄƒr aparat Ã®n CSV (este Ã®n filename!)
- âŒ Orice informaÈ›ie identificabilÄƒ

**FrecvenÈ›Äƒ Ã®nregistrare:** ~4 secunde Ã®ntre mÄƒsurÄƒtori (poate varia).

**PDF Rapoarte Format:**
```
Checkme O2 [APARAT]_[MIN]_[MAX]_[YYYYMMDDHHMMSS].pdf
```
Exemple:
- `Checkme O2 0331_70_100_20251015203510.pdf` 
  - Aparat: 0331
  - Parametri alerte: Min SpO2=70%, Max SpO2=100%
  - Timestamp: 15 Oct 2025 20:35:10

**Workflow Bulk Upload Medic:**

**Model REAL:** 1 PACIENT = 1 LINK PERSISTENT (poate avea MULTIPLE Ã®nregistrÄƒri)

1. **Medicul uploadeazÄƒ BULK** fiÈ™iere pentru multiple Ã®nregistrÄƒri (5-10 teste):
   ```
   Test 1: Checkme O2 0331_20251015203510.csv + .pdf (Aparat 0331, 15 Oct)
   Test 2: Checkme O2 3539_20251015210000.csv + .pdf (Aparat 3539, 15 Oct)
   Test 3: Checkme O2 0331_20251016203000.csv + .pdf (Aparat 0331, 16 Oct)
   Test 4: Checkme O2 3539_20251017220000.csv + .pdf (Aparat 3539, 17 Oct)
   etc. (5-10 perechi CSV+PDF)
   ```

2. **Sistem proceseazÄƒ** fiÈ™ierele:
   - Parsare CSV â†’ date medicale
   - Parsare PDF â†’ raport â†’ JSONB DB
   - **AfiÈ™are dialog**: "SelectaÈ›i pacient pentru fiecare Ã®nregistrare"

3. **Medic asociazÄƒ manual** fiecare test la un pacient:
   ```
   Test 1 (Aparat 0331, 15 Oct):
     âšª OPÈšIUNE A: CreeazÄƒ LINK NOU (pacient nou "Ion Popescu")
        â†’ Sistem genereazÄƒ: https://app.com/view/abc123-uuid
        â†’ Link PERSISTENT pentru Ion Popescu
   
   Test 2 (Aparat 3539, 15 Oct):
     âšª OPÈšIUNE A: CreeazÄƒ LINK NOU (pacient nou "Maria Ionescu")
        â†’ Sistem genereazÄƒ: https://app.com/view/def456-uuid
   
   Test 3 (Aparat 0331, 16 Oct):
     âš« OPÈšIUNE B: ADAUGÄ‚ la link EXISTENT
        â†’ Medic selecteazÄƒ link: "Ion Popescu (abc123)"
        â†’ Test 3 se adaugÄƒ la acelaÈ™i link (https://app.com/view/abc123)
        â†’ Ion vede acum 2 Ã®nregistrÄƒri pe acelaÈ™i link (15 Oct + 16 Oct)
   
   Test 4 (Aparat 3539, 17 Oct):
     âš« OPÈšIUNE B: ADAUGÄ‚ la link EXISTENT
        â†’ Medic selecteazÄƒ: "Maria Ionescu (def456)"
   ```

4. **MERGE LINKS** (pentru acelaÈ™i pacient cu link-uri diferite):
   ```
   Scenariu: Ion Popescu are 2 link-uri (aparate diferite Ã®n nopÈ›i diferite):
     - Link 1 (abc123): Test cu Aparat 0331, 15 Oct
     - Link 2 (xyz789): Test cu Aparat 3539, 16 Oct
   
   Medic selecteazÄƒ: "Merge link xyz789 â†’ abc123"
   â†’ Rezultat: Toate testele lui Ion acum pe https://app.com/view/abc123
   â†’ Link xyz789 devine invalid (redirect cÄƒtre abc123)
   â†’ Ion vede 2 Ã®nregistrÄƒri SEPARATE pe acelaÈ™i link:
       - Ãnregistrare 1: 15 Oct, Aparat 0331 (grafic + raport)
       - Ãnregistrare 2: 16 Oct, Aparat 3539 (grafic + raport)
   ```

5. **Medic trimite link-ul persistent** cÄƒtre pacient (email/SMS)

**IMPORTANT:**
- âœ… **Link-uri PERSISTENTE**: 1 link = 1 pacient real (poate avea N teste)
- âœ… **"AdaugÄƒ la link existent"**: Control/test nou pentru acelaÈ™i pacient
- âœ… **"Merge links"**: Unire link-uri pentru acelaÈ™i pacient (date SEPARATE, nu amestecate)
- âœ… **AfiÈ™are SEPARATÄ‚**: Fiecare test = card/secÈ›iune distinctÄƒ pe pagina pacientului
- âœ… **AcelaÈ™i aparat, zile diferite**: Poate fi acelaÈ™i pacient (medic decide)
- âœ… **Aparate diferite, aceeaÈ™i zi**: Poate fi acelaÈ™i pacient (medic decide)
- âœ… **Link salvat o datÄƒ**: Pacient bookmarkeazÄƒ, acceseazÄƒ oricÃ¢nd (fÄƒrÄƒ expirare)

### Parsing Pattern (Data Parser REAL - Format Checkme O2)
```python
from typing import Optional, Dict, Tuple
import pandas as pd
import os
import re
from logger_setup import setup_logger

logger = setup_logger(__name__)

def extract_device_from_filename(filename: str) -> Optional[str]:
    """
    Extrage numÄƒrul aparatului din numele fiÈ™ierului.
    
    Format: "Checkme O2 0331_20251015203510.csv" â†’ "0331"
    """
    match = re.search(r'Checkme O2 (\d{4})_', filename)
    if match:
        return match.group(1)
    logger.warning(f"Could not extract device number from: {filename}")
    return None

def parse_checkme_csv(file_path: str) -> Optional[Tuple[pd.DataFrame, str]]:
    """
    ParseazÄƒ fiÈ™ier CSV Checkme O2 cu format romÃ¢nesc.
    
    Args:
        file_path: Calea cÄƒtre fiÈ™ierul CSV
        
    Returns:
        Tuple (DataFrame cu coloane: DateTime, SpO2, Puls, Miscare, device_num)
        sau None dacÄƒ eroare
    """
    tag = "parse_checkme_csv"
    logger.info(f"[{tag}] START parsing: {file_path}")
    
    try:
        # Extrage numÄƒrul aparatului din filename
        filename = os.path.basename(file_path)
        device_num = extract_device_from_filename(filename)
        if not device_num:
            logger.error(f"[{tag}] Cannot extract device number from filename")
            return None
        
        # Citire CSV cu encoding UTF-8 (pentru caractere romÃ¢neÈ™ti)
        df = pd.read_csv(file_path, encoding='utf-8')
        
        # Validare coloane obligatorii (ROMÃ‚NÄ‚!)
        required_cols = ['Timp', 'Nivel de oxigen', 'Puls cardiac']
        if not all(col in df.columns for col in required_cols):
            logger.error(f"[{tag}] Missing required columns. Found: {df.columns.tolist()}")
            return None
        
        # VERIFICARE CRITICÄ‚: AsigurÄƒ-te cÄƒ NU existÄƒ date personale
        forbidden_cols = ['Nume', 'Prenume', 'Name', 'CNP', 'Phone', 
                         'Telefon', 'Email', 'Address', 'Adresa', 'Patient', 'Pacient']
        found_forbidden = [col for col in forbidden_cols if col in df.columns]
        if found_forbidden:
            logger.error(f"[{tag}] PRIVACY VIOLATION: Found personal data columns: {found_forbidden}")
            return None
        
        # Parsare timestamp din format romÃ¢nesc: "HH:MM:SS DD/MM/YYYY"
        df['DateTime'] = pd.to_datetime(
            df['Timp'], 
            format='%H:%M:%S %d/%m/%Y'
        )
        
        # Redenumire coloane pentru consistenÈ›Äƒ
        df = df.rename(columns={
            'Nivel de oxigen': 'SpO2',
            'Puls cardiac': 'Puls',
            'MiÅŸcare': 'Miscare'  # opÈ›ional
        })
        
        # Validare date medicale
        initial_count = len(df)
        df = df[(df['SpO2'] >= 0) & (df['SpO2'] <= 100)]
        df = df[(df['Puls'] >= 30) & (df['Puls'] <= 200)]
        
        filtered_count = initial_count - len(df)
        if filtered_count > 0:
            logger.warning(f"[{tag}] Filtered {filtered_count} invalid medical values")
        
        logger.info(f"[{tag}] SUCCESS: {len(df)} records parsed from device {device_num}")
        
        # SelecteazÄƒ coloanele finale
        cols = ['DateTime', 'SpO2', 'Puls']
        if 'Miscare' in df.columns:
            cols.append('Miscare')
        
        return df[cols], device_num
        
    except Exception as e:
        logger.error(f"[{tag}] ERROR: {str(e)}", exc_info=True)
        return None
```

### Dash Callback Pattern
```python
from dash import Input, Output, State, callback
from dash.exceptions import PreventUpdate

@callback(
    Output('interactive-graph', 'figure'),
    Output('output-filename-container', 'children'),
    Input('upload-data-component', 'contents'),
    State('upload-data-component', 'filename'),
    prevent_initial_call=True
)
def update_graph(contents, filename):
    """
    Callback pentru actualizare grafic la upload fiÈ™ier CSV.
    """
    tag = "update_graph_callback"
    logger.info(f"[{tag}] START - File: {filename}")
    
    if contents is None:
        logger.warning(f"[{tag}] No file uploaded")
        raise PreventUpdate
    
    try:
        # Decode base64 content
        df = decode_csv_from_upload(contents)
        
        # Generare grafic
        fig = generate_interactive_plot(df, filename)
        
        success_msg = html.Div(
            f"âœ… FiÈ™ier Ã®ncÄƒrcat: {filename}",
            style={'color': 'green', 'marginTop': '10px'}
        )
        
        logger.info(f"[{tag}] SUCCESS")
        return fig, success_msg
        
    except Exception as e:
        logger.error(f"[{tag}] ERROR: {str(e)}", exc_info=True)
        error_msg = html.Div(
            f"âŒ Eroare la procesare: {str(e)}",
            style={'color': 'red', 'marginTop': '10px'}
        )
        return go.Figure(), error_msg
```

## ğŸš€ Proces de Dezvoltare

### Pentru fiecare task:
1. **Analiza (7 min)** - CiteÈ™te cerinÈ›ele, identificÄƒ complexitatea
2. **Design (15 min)** - Propune 5+ soluÈ›ii, evalueazÄƒ Pro/Contra
3. **Implementare** - Cod defensiv, logging (min 7), error handling
4. **Review (7 min)** - Self-review cu checklist, quality gates

## ğŸ’¡ Best Practices

### DO âœ…
- **ValideazÄƒ CSV format Checkme O2**: Coloane Ã®n ROMÃ‚NÄ‚ (`Timp`, `Nivel de oxigen`, `Puls cardiac`, `MiÅŸcare`)
- **ParseazÄƒ timestamp romÃ¢nesc**: Format `HH:MM:SS DD/MM/YYYY` (nu englezesc!)
- **Extrage device number din filename**: Regex `Checkme O2 (\d{4})_`
- **VerificÄƒ absenÈ›a date personale** (CSV conÈ›ine DOAR date medicale + timestamp)
- **Encoding UTF-8**: Pentru caractere romÃ¢neÈ™ti (Äƒ, Ã¢, Ã®, È™, È›)
- FoloseÈ™te type hints Python pentru claritate
- ImplementeazÄƒ error handling pentru CSV corrupt/format greÈ™it
- LogheazÄƒ comprehensiv cu logger_setup.py (fÄƒrÄƒ date identificabile!)
- TesteazÄƒ grafice pe multiple rezoluÈ›ii
- Configurare externÄƒ (config.py, colors_config.json)
- ImplementeazÄƒ loading states Ã®n Dash (dcc.Loading)
- FoloseÈ™te pandas vectorization (evitÄƒ loops)
- **Token-uri PERSISTENTE** pentru link-uri (UUID v4, reutilizabile pentru acelaÈ™i pacient)
- **Asociere manualÄƒ** medic â†’ test la pacient (link nou SAU link existent)
- **Merge links** pentru acelaÈ™i pacient (unire 2+ link-uri â†’ toate datele Ã®n 1 link)
- **AfiÈ™are multiplÄƒ** Ã®nregistrÄƒri pe acelaÈ™i link (secÈ›iuni SEPARATE, nu amestecate)
- **Format titlu descriptiv** per Ã®nregistrare cu zi sÄƒptÄƒmÃ¢nÄƒ + context temporal
- **NumÄƒr aparat ca string** (ex: "0331" NU 331 - pÄƒstreazÄƒ zero-ul leading!)
- **1 pacient = 1 link persistent** (poate avea N teste Ã®n timp)

### DON'T âŒ
- **NU presupune coloane Ã®n englezÄƒ** (sunt Ã®n romÃ¢nÄƒ: `Timp`, nu `Time`!)
- **NU converteÈ™ti numÄƒr aparat la integer** (pÄƒstreazÄƒ "0331" ca string!)
- **NU ignora encoding UTF-8** (caractere romÃ¢neÈ™ti se corupe fÄƒrÄƒ UTF-8)
- Nu ignora erori de parsing CSV (format timestamp greÈ™it)
- Nu hard-codezi culori/limite medicale
- Nu folosi print() Ã®n producÈ›ie (doar logger)
- Nu lÄƒsa memory leaks (Ã®nchide file handles)
- Nu ignora accessibility (ARIA labels Ã®n Dash)
- Nu commit fÄƒrÄƒ testing pe date reale (CSV-uri Checkme O2!)
- Nu procesa CSV fÄƒrÄƒ validare medicalÄƒ
- Nu folosi magic numbers (SaO2/Puls limits Ã®n config)
- **NU stoca date personale Ã®n CSV/timestamp** (nume, CNP Ã®n fiÈ™iere date)
- **NU genera ID-uri predictibile** (foloseÈ™te UUID/secrets pentru token-uri)
- **NU include date identificabile Ã®n metadata EXIF** (PNG/JPG exportate)
- **NU presupune frecvenÈ›Äƒ fixÄƒ** (poate varia Ã®ntre 3-5 secunde)
- **NU amesteca datele** din Ã®nregistrÄƒri diferite (afiÈ™are SEPARATÄ‚ obligatorie!)
- **NU È™tergi link-ul source** la merge (redirect, nu delete, pentru bookmark-uri vechi)

## ğŸ¯ Target Metrics
- **CSV Parsing Time**: < 2s pentru 10,000 Ã®nregistrÄƒri
- **Graph Generation**: < 3s pentru 8h de date
- **Memory Usage**: < 500MB pentru batch processing
- **Error Rate**: < 0.5% (date medicale critice)
- **Mobile Responsive**: Grafice lizibile pe 360px width

## ğŸ“Š Specific pentru Pulsoximetrie

### ğŸ¥ Model Date: 1 PACIENT = 1 LINK PERSISTENT (Multiple ÃnregistrÄƒri)
- **Link Persistent:** 1 link = 1 pacient real (poate avea N teste Ã®n timp)
- **Exemplu:** Pacient "Ion Popescu" â†’ link ABC123 â†’ 3 teste (15 Oct, 16 Oct, 20 Oct)
- **Bulk Upload:** Medic uploadeazÄƒ 10-20 fiÈ™iere â†’ asociazÄƒ manual la pacienÈ›i (link-uri noi sau existente)
- **Distribuire:** Medic trimite link persistent o singurÄƒ datÄƒ â†’ pacient bookmarkeazÄƒ
- **Teste noi:** Medic adaugÄƒ la acelaÈ™i link â†’ pacient vede automat (refresh paginÄƒ)
- **Merge Links:** Medic poate uni 2+ link-uri ale aceluiaÈ™i pacient â†’ toate datele Ã®n 1 link
- **AfiÈ™are:** Fiecare test = secÈ›iune SEPARATÄ‚ pe pagina pacientului (nu se amestecÄƒ datele)

### ğŸ”’ Anonimizare Date (Privacy by Design)
- **ZERO date personale**: CSV-uri conÈ›in DOAR timestamp + date medicale + numÄƒr aparat
- **FÄƒrÄƒ nume/prenume**: Identificare exclusiv prin token link (generat automat)
- **FÄƒrÄƒ CNP/telefon**: Nu se stocheazÄƒ date identificabile
- **GDPR Simplificat**: Date anonime = fÄƒrÄƒ consimÈ›ÄƒmÃ¢nt explicit necesar
- **Link-uri Token-Based**: Format `https://app.com/view/abc123xyz` (UUID random)

### ğŸ”— Model Link-uri PERSISTENTE + Merge
- **1 LINK = 1 PACIENT REAL** (poate avea multiple Ã®nregistrÄƒri)
- **Link Persistent:** https://app.com/view/abc123-uuid (valid indefinit, fÄƒrÄƒ expirare)
- **Token format**: UUID v4 random (ex: `abc123-7f3a2b1c-9d4e-4f5a-8b6c`)
- **Asociere ManualÄƒ**: Medic selecteazÄƒ pentru fiecare test: Link NOU sau Link EXISTENT
- **Multiple Teste**: 1 link â†’ N Ã®nregistrÄƒri (afiÈ™ate SEPARAT ca liste/carduri)

**Exemplu Workflow Complet:**
```
PACIENT: Ion Popescu

Test 1 (15 Oct, Aparat 0331):
  â†’ Medic: "CreeazÄƒ link NOU"
  â†’ Sistem genereazÄƒ: https://app.com/view/ion-abc123
  â†’ Medic trimite link cÄƒtre Ion

Test 2 (16 Oct, Aparat 0331):
  â†’ Medic: "AdaugÄƒ la link existent: Ion Popescu (abc123)"
  â†’ Sistemul adaugÄƒ test la acelaÈ™i link
  â†’ Ion acceseazÄƒ acelaÈ™i link â†’ vede 2 Ã®nregistrÄƒri

Test 3 (20 Oct, Aparat 3539 - aparat DIFERIT):
  â†’ Medic (greÈ™ealÄƒ): "CreeazÄƒ link NOU" 
  â†’ Sistem genereazÄƒ: https://app.com/view/ion-xyz789
  â†’ Acum Ion are 2 link-uri diferite!

MERGE LINKS:
  â†’ Medic: "Merge link xyz789 Ã®n abc123"
  â†’ Toate testele acum Ã®n https://app.com/view/ion-abc123
  â†’ Link xyz789 â†’ redirect cÄƒtre abc123
  â†’ Ion vede 3 Ã®nregistrÄƒri pe un singur link:
      1. 15 Oct, Aparat 0331 (secÈ›iune separatÄƒ)
      2. 16 Oct, Aparat 0331 (secÈ›iune separatÄƒ)
      3. 20 Oct, Aparat 3539 (secÈ›iune separatÄƒ)
```

**AfiÈ™are PaginÄƒ Pacient:**
```
[Header] ÃnregistrÄƒrile Tale - Link: abc123

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š ÃNREGISTRARE 1
MarÈ›i 15 Octombrie 2025 seara ora 20:35 
pÃ¢nÄƒ Ã®n Miercuri 16 Octombrie ora 06:31
Aparat: 0331
[Grafic interactiv SpO2 + Puls]
[Raport PDF interpretat]
[Download CSV] [Download PNG]
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š ÃNREGISTRARE 2
Miercuri 16 Octombrie 2025 seara ora 21:00
pÃ¢nÄƒ Ã®n Joi 17 Octombrie ora 07:15
Aparat: 0331
[Grafic interactiv SpO2 + Puls]
[Raport PDF interpretat]
[Download CSV] [Download PNG]
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š ÃNREGISTRARE 3
DuminicÄƒ 20 Octombrie 2025 seara ora 22:30
pÃ¢nÄƒ Ã®n Luni 21 Octombrie ora 06:45
Aparat: 3539 (aparat diferit!)
[Grafic interactiv SpO2 + Puls]
[Raport PDF interpretat]
[Download CSV] [Download PNG]
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

### ğŸ“‹ Format Titlu PaginÄƒ Pacient
Pagina pacientului afiÈ™eazÄƒ titlu descriptiv **fÄƒrÄƒ nume**, dar cu context temporal:

**Format:**
```
Ãnregistrare din [Zi SÄƒptÄƒmÃ¢nÄƒ] [Data] [Moment Zi] ora [HH:MM]
pÃ¢nÄƒ Ã®n [Zi SÄƒptÄƒmÃ¢nÄƒ] [Data] ora [HH:MM] [Status] - Aparat [NNNN]
```

**Exemple concrete:**
- `Ãnregistrare din Joi 2 Mai 2025 seara ora 23:30 pÃ¢nÄƒ Ã®n Vineri 3 Mai 2025 ora 06:37 - Aparat 3539`
- `Ãnregistrare din MarÈ›i 7 Mai 2025 dupÄƒ ora 12:15 pÃ¢nÄƒ Ã®n Miercuri 8 Mai 2025 ora 02:30 (Ã®ntreruptÄƒ Ã®nainte de ora 12 noaptea) - Aparat 0563`

**Reguli pentru moment zi (START):**
- **"seara"** â†’ DacÄƒ ora Ã®nceput â‰¥ 20:00
- **"dupÄƒ ora 12"** â†’ DacÄƒ ora Ã®nceput â‰¥ 12:00 È™i < 20:00
- **"dimineaÈ›a"** â†’ DacÄƒ ora Ã®nceput < 12:00

**Reguli pentru status (END):**
- **"(Ã®ntreruptÄƒ Ã®nainte de ora 12 noaptea)"** â†’ DacÄƒ Ã®nregistrarea se terminÄƒ Ã®nainte de miezul nopÈ›ii (00:00) a doua zi
  - Exemplu: Start 2 Mai 23:30 â†’ End 3 Mai 02:30 = OK (continuÄƒ peste 00:00)
  - Exemplu: Start 2 Mai 23:30 â†’ End 2 Mai 23:59 = ÃNTRERUPTÄ‚ (se terminÄƒ Ã®nainte de 00:00)
- **Nimic** â†’ DacÄƒ Ã®nregistrarea continuÄƒ peste 00:00 (Ã®nregistrare completÄƒ nocturnÄƒ)

**Implementare:**
```python
from datetime import datetime, timedelta

def generate_recording_title(start_dt: datetime, end_dt: datetime, device_num: str) -> str:
    """
    GenereazÄƒ titlu descriptiv pentru pagina pacientului.
    
    Args:
        start_dt: Datetime Ã®nceput Ã®nregistrare
        end_dt: Datetime sfÃ¢rÈ™it Ã®nregistrare
        device_num: NumÄƒr aparat (ex: "3539", "0563")
    
    Returns:
        Titlu complet cu zi sÄƒptÄƒmÃ¢nÄƒ, date, context temporal
    """
    # Zile sÄƒptÄƒmÃ¢nÄƒ Ã®n romÃ¢nÄƒ
    days_ro = ['Luni', 'MarÈ›i', 'Miercuri', 'Joi', 'Vineri', 'SÃ¢mbÄƒtÄƒ', 'DuminicÄƒ']
    
    # Formatare datÄƒ: "2 Mai 2025"
    start_day = days_ro[start_dt.weekday()]
    start_date = start_dt.strftime("%d %B %Y").lstrip('0')  # Remove leading zero
    
    # Moment zi pentru START
    if start_dt.hour >= 20:
        moment = "seara"
    elif start_dt.hour >= 12:
        moment = "dupÄƒ ora 12"
    else:
        moment = "dimineaÈ›a"
    
    # Verificare dacÄƒ Ã®nregistrare Ã®ntreruptÄƒ
    # ÃntreruptÄƒ = se terminÄƒ Ã®nainte de 00:00 (miezul nopÈ›ii) zilei urmÄƒtoare
    next_midnight = start_dt.replace(hour=0, minute=0, second=0) + timedelta(days=1)
    is_interrupted = end_dt < next_midnight
    status = " (Ã®ntreruptÄƒ Ã®nainte de ora 12 noaptea)" if is_interrupted else ""
    
    # Formatare END
    end_day = days_ro[end_dt.weekday()]
    end_date = end_dt.strftime("%d %B %Y").lstrip('0')
    
    title = (
        f"Ãnregistrare din {start_day} {start_date} {moment} "
        f"ora {start_dt.strftime('%H:%M')} pÃ¢nÄƒ Ã®n {end_day} {end_date} "
        f"ora {end_dt.strftime('%H:%M')}{status} - Aparat {device_num}"
    )
    
    return title
```

**Test Cases - Exemple Concrete:**

| FiÈ™ier CSV | Start | End | Titlu AÈ™teptat |
|------------|-------|-----|----------------|
| `Checkme O2 0331_20251015203510.csv` | MarÈ›i 15 Oct 20:35 | Miercuri 16 Oct 06:31 | `Ãnregistrare din MarÈ›i 15 Octombrie 2025 seara ora 20:35 pÃ¢nÄƒ Ã®n Miercuri 16 Octombrie 2025 ora 06:31 - Aparat 0331` |
| `Checkme O2 3539_20250502233000.csv` | Joi 2 Mai 23:30 | Vineri 3 Mai 06:37 | `Ãnregistrare din Joi 2 Mai 2025 seara ora 23:30 pÃ¢nÄƒ Ã®n Vineri 3 Mai 2025 ora 06:37 - Aparat 3539` |
| `Checkme O2 0563_20250507151000.csv` | MarÈ›i 7 Mai 15:10 | MarÈ›i 7 Mai 22:45 | `Ãnregistrare din MarÈ›i 7 Mai 2025 dupÄƒ ora 12 ora 15:10 pÃ¢nÄƒ Ã®n MarÈ›i 7 Mai 2025 ora 22:45 (Ã®ntreruptÄƒ Ã®nainte de ora 12 noaptea) - Aparat 0563` |
| `Checkme O2 3539_20250510103000.csv` | SÃ¢mbÄƒtÄƒ 10 Mai 10:30 | SÃ¢mbÄƒtÄƒ 10 Mai 18:00 | `Ãnregistrare din SÃ¢mbÄƒtÄƒ 10 Mai 2025 dimineaÈ›a ora 10:30 pÃ¢nÄƒ Ã®n SÃ¢mbÄƒtÄƒ 10 Mai 2025 ora 18:00 (Ã®ntreruptÄƒ Ã®nainte de ora 12 noaptea) - Aparat 3539` |

**Exemplu REAL analizat:**
- **FiÈ™ier:** `Checkme O2 0331_20251015203510.csv`
- **ÃnregistrÄƒri:** 9,003 rÃ¢nduri (aprox. 10 ore)
- **Prima Ã®nregistrare:** `20:35:10 15/10/2025,92,78,0`
- **Ultima Ã®nregistrare:** `06:31:38 16/10/2025,96,59,0`
- **FrecvenÈ›Äƒ:** 4 secunde Ã®ntre mÄƒsurÄƒtori
- **SpO2 minim detectat:** 66% (episod hipoxemie severÄƒ!)
- **SpO2 maxim:** 96%
- **Puls minim:** 49 bpm
- **Puls maxim:** 79 bpm
- **Indicator miÈ™care maxim:** 25 (moment cu artefacte)

### ğŸ“Š Validare Date Medicale
- **SaO2**: 0-100% (alerte < 88% - hipoxemie severÄƒ)
- **Puls**: 30-200 bpm (alerte < 40 sau > 120 - anomalii)
- **Timestamp**: Validare continuitate (detectare gap-uri > 10 secunde)
- **NumÄƒr Aparat**: Format string 4 cifre: "3539", "0563", "3541", etc.
  - Poate Ã®ncepe cu 0 (ex: "0563")
  - Se stocheazÄƒ ca string (NU integer pentru a pÄƒstra 0-ul leading)
  - Se extrage din filename CSV sau se atribuie manual de medic

### ğŸ–¼ï¸ Export & Branding
- **Watermark**: Logo clinicÄƒ + telefon + adresÄƒ (pe toate PNG-urile)
- **Metadata**: ZERO informaÈ›ii pacient Ã®n metadata EXIF
- **Batch Processing**: Foldere denumite `15oct2025_20h35-06h31_Aparat0331`
- **Link Token**: UUID unic per Ã®nregistrare (nu reutilizabil, nu predictibil)
- **PDF Parsing**: Rapoarte parsate â†’ JSONB (fÄƒrÄƒ date identificare)
- **Denumire Export**: `15oct2025_20h35-06h31_Aparat0331.png` (fÄƒrÄƒ nume pacient!)

---

> **"Code is read 10x more than it's written"** - Scrie cod pentru urmÄƒtorul dezvoltator!
> **"Medical data is critical"** - Zero compromisuri pe validare È™i securitate!

**Versiune:** 1.0 Pulsoximetrie | **Pentru:** Analizator Date Pulsoximetrie + Cloud Platform  
**Tehnologie ActualÄƒ:** Python + Dash + Plotly + pandas + Kaleido  
**Tehnologie Viitoare (Cloud):** FastAPI + PostgreSQL + Cloudflare R2 + Railway

